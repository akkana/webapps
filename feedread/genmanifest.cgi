#!/usr/bin/env python3

# Some older directories, or directories that weren't generated by feedme,
# may not have manifests. In that case, a web app can't fetch them reliably.
# This is a CGI script that generates a manifest, writes it to the
# appropriate directory (so it will be there next time),
# then returns the contents.

# Expects feedURL in either GET or POST data; returns text/plain.

import json
import urllib.parse

import sys, os

for key in sorted(os.environ):
    print("%s: '%s'   " % (key, os.environ[key]), file=sys.stderr)

try:
    if os.environ['REQUEST_METHOD'] == 'GET':
        req_dict = urllib.parse.parse_qs(os.environ['QUERY_STRING'])
        feedURL = req_dict['feedURL'][0]

    elif os.environ['REQUEST_METHOD'] == 'POST':
        content_len = int(os.environ["CONTENT_LENGTH"])
        req_body = sys.stdin.read(content_len)
        req_dict = json.loads(req_body)
        feedURL = req_dict['feedURL']

    doc_root = os.environ['DOCUMENT_ROOT']

except Exception as e:
    print("Problem parsing arguments", file=sys.stderr)
    raise(e)

print("""Content-type: text/plain
Content-Disposition: inline; filename=MANIFEST
""")

print("feedURL:", feedURL, file=sys.stderr)
manfp = open(os.path.join(doc_root + feedURL, 'MANIFEST'), 'w')

os.chdir(doc_root + feedURL)
htmlfiles = []
mediafiles = []
controlfiles = []
for root, dirs, files in os.walk('.'):
    for f in files:
        if f == 'MANIFEST' or f == 'LOG':
            controlfiles.append(os.path.normpath(os.path.join(root, f)))
        elif '.htm' in f.lower() or '.txt' in f.lower():
            htmlfiles.append(os.path.normpath(os.path.join(root, f)))
        else:
            mediafiles.append(os.path.normpath(os.path.join(root, f)))

for f in htmlfiles + controlfiles + mediafiles:
    print(f, file=manfp)
    print(f)

manfp.close()




